<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>WebRTC Test</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        .video-container {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        video {
            width: 45%;
            min-width: 300px;
            margin: 10px;
            border: 2px solid #ccc;
            border-radius: 8px;
            background-color: #000;
        }
        #status {
            padding: 15px;
            margin: 10px;
            background: #fff;
            border-radius: 8px;
            display: inline-block;
            min-width: 300px;
            text-align: left;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        #reconnectButton {
            padding: 10px 20px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            display: none;
            margin: 10px;
        }
        #reconnectButton:hover {
            background-color: #45a049;
        }
        .error {
            color: red;
            font-weight: bold;
        }
    </style>
    <script src="https://cdn.ably.io/lib/ably.min-1.js"></script>
</head>
<body>
    <div class="container">
        <h1>WebRTC Test</h1>
        <div id="status">Инициализация...</div>
        <button id="reconnectButton" onclick="reconnect()">Переподключиться</button>
        <div class="video-container">
            <video id="localVideo" autoplay muted playsinline></video>
            <video id="remoteVideo" autoplay playsinline></video>
        </div>
    </div>

    <script>
        // Конфигурация
        const ABLY_KEY = 'QBEN4A.NpllMw:gKZi9zUxR4vJRISVloUyOSyO969QngOBQNAvtLSr3ZA';
        const ICE_SERVERS = [
            { urls: 'stun:stun.l.google.com:19302' },
            { urls: 'stun:stun1.l.google.com:19302' },
            { urls: 'stun:stun2.l.google.com:19302' },
            { urls: 'stun:stun3.l.google.com:19302' },
            { urls: 'stun:stun4.l.google.com:19302' }
        ];

        // Элементы UI
        const statusEl = document.getElementById('status');
        const localVideo = document.getElementById('localVideo');
        const remoteVideo = document.getElementById('remoteVideo');
        const reconnectButton = document.getElementById('reconnectButton');

        // Глобальные переменные
        let localStream;
        let peerConnection;
        let ably;
        let channel;
        let pendingCandidates = [];
        let isCaller = false;
        let hasSetRemoteDescription = false;
        let hasHandledOffer = false;
        let isReconnecting = false;

        // Инициализация
        init();

        async function init() {
            try {
                localStream = await navigator.mediaDevices.getUserMedia({ 
                    video: true, 
                    audio: true 
                });
                localVideo.srcObject = localStream;
                log('Локальные медиа получены');

                const roomId = getParams().roomId;
                log('Комната:', roomId);

                await setupAbly();
                await setupChannel(roomId);

            } catch (err) {
                errorHandler('Ошибка инициализации: ' + err.message);
                showReconnectButton();
            }
        }

        async function setupAbly() {
            ably = new Ably.Realtime({
                key: ABLY_KEY,
                clientId: 'user-' + Math.random().toString(16).slice(2)
            });

            return new Promise((resolve, reject) => {
                ably.connection.once('connected', () => {
                    log('Ably подключен. ID:', ably.auth.clientId);
                    resolve();
                });

                ably.connection.once('failed', (err) => {
                    reject(new Error('Ably connection failed: ' + err));
                });

                ably.connection.on('disconnected', () => {
                    log('Ably отключен');
                    showReconnectButton();
                });
            });
        }

        async function setupChannel(roomId) {
            channel = ably.channels.get(`room-${roomId}`);
            
            // Подписка на сигналы
            channel.subscribe('signal', handleSignal);

            await channel.presence.enter({ role: 'participant' });
            log('Вошли в канал присутствия');

            const members = await new Promise((resolve, reject) => {
                channel.presence.get((err, members) => {
                    if (err) reject(err);
                    else resolve(members);
                });
            });

            log('Участники:', members.map(m => m.clientId).join(', '));

            if (members.length === 1) {
                isCaller = true;
                log('Вы первый - Caller');
                await startCall();
            } else {
                isCaller = false;
                log('Вы второй - Callee');
            }

            // Мониторинг presence
            channel.presence.subscribe(handlePresenceUpdate);
        }

        function handleSignal(msg) {
            if (msg.clientId === ably.auth.clientId) return;

            log('Сигнал получен:', msg.data.type);
            
            switch (msg.data.type) {
                case 'offer':
                    handleOffer(msg.data.offer);
                    break;
                case 'answer':
                    handleAnswer(msg.data.answer);
                    break;
                case 'candidate':
                    handleCandidate(msg.data.candidate);
                    break;
            }
        }

        async function handlePresenceUpdate(msg) {
            log('Presence update:', msg.action, msg.clientId);
            
            if (msg.action === 'leave' || msg.action === 'absent') {
                if (msg.clientId !== ably.auth.clientId) {
                    log('Участник покинул комнату');
                    await cleanupPeerConnection();
                    if (isCaller) {
                        await startCall();
                    }
                }
            }
        }

        async function startCall() {
            if (!isCaller || isReconnecting) return;
            
            try {
                await cleanupPeerConnection();
                
                peerConnection = createPeerConnection();
                log('PeerConnection создан');

                localStream.getTracks().forEach(track => {
                    peerConnection.addTrack(track, localStream);
                });

                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);
                log('Offer создан');

                await publishSignal('offer', { offer });
                log('Offer отправлен');

            } catch (err) {
                errorHandler('Ошибка startCall: ' + err.message);
                showReconnectButton();
            }
        }

        async function handleOffer(offer) {
            if (isCaller || hasHandledOffer || isReconnecting) return;

            try {
                await cleanupPeerConnection();
                hasHandledOffer = true;

                peerConnection = createPeerConnection();
                log('PeerConnection создан (Callee)');

                localStream.getTracks().forEach(track => {
                    peerConnection.addTrack(track, localStream);
                });

                await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
                log('RemoteDescription установлен');

                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);
                log('Answer создан');

                await publishSignal('answer', { answer });
                log('Answer отправлен');

                processPendingCandidates();

            } catch (err) {
                errorHandler('Ошибка handleOffer: ' + err.message);
                hasHandledOffer = false;
                showReconnectButton();
            }
        }

        async function handleAnswer(answer) {
            if (!isCaller || !peerConnection || hasSetRemoteDescription) return;

            try {
                await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
                hasSetRemoteDescription = true;
                log('Answer принят');
                processPendingCandidates();
            } catch (err) {
                errorHandler('Ошибка handleAnswer: ' + err.message);
                showReconnectButton();
            }
        }

        async function handleCandidate(candidate) {
            try {
                if (!peerConnection) {
                    pendingCandidates.push(candidate);
                    return;
                }

                if (!peerConnection.remoteDescription) {
                    pendingCandidates.push(candidate);
                    return;
                }

                await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                log('ICE кандидат добавлен');
            } catch (err) {
                errorHandler('Ошибка handleCandidate: ' + err.message);
            }
        }

        function createPeerConnection() {
            const pc = new RTCPeerConnection({ iceServers: ICE_SERVERS });

            pc.onicecandidate = async ({ candidate }) => {
                if (candidate) {
                    try {
                        await publishSignal('candidate', { candidate });
                        log('ICE кандидат отправлен');
                    } catch (err) {
                        errorHandler('Ошибка отправки ICE кандидата: ' + err.message);
                    }
                }
            };

            pc.ontrack = (event) => {
                if (remoteVideo.srcObject !== event.streams[0]) {
                    remoteVideo.srcObject = event.streams[0];
                    log('Удаленный стрим получен');
                }
            };

            pc.onconnectionstatechange = () => {
                log('Connection state:', pc.connectionState);
                if (pc.connectionState === 'connected') {
                    hideReconnectButton();
                } else if (pc.connectionState === 'failed') {
                    showReconnectButton();
                }
            };

            pc.oniceconnectionstatechange = () => {
                log('ICE Connection state:', pc.iceConnectionState);
            };

            return pc;
        }

        async function publishSignal(type, data) {
            try {
                await channel.publish('signal', { type, ...data });
            } catch (err) {
                throw new Error(`Ошибка отправки сигнала ${type}: ${err.message}`);
            }
        }

        async function cleanupPeerConnection() {
            if (peerConnection) {
                if (remoteVideo.srcObject) {
                    remoteVideo.srcObject.getTracks().forEach(track => track.stop());
                    remoteVideo.srcObject = null;
                }

                peerConnection.close();
                peerConnection = null;
            }

            hasSetRemoteDescription = false;
            hasHandledOffer = false;
            pendingCandidates = [];
        }

        async function processPendingCandidates() {
            while (pendingCandidates.length > 0 && peerConnection?.remoteDescription) {
                const candidate = pendingCandidates.shift();
                try {
                    await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                    log('Отложенный ICE кандидат добавлен');
                } catch (err) {
                    errorHandler('Ошибка добавления отложенного кандидата: ' + err.message);
                }
            }
        }

        async function reconnect() {
            if (isReconnecting) return;
            
            isReconnecting = true;
            log('Переподключение...');
            
            try {
                await cleanupPeerConnection();
                
                if (ably) {
                    await channel.presence.leave();
                    ably.close();
                }

                await init();
                hideReconnectButton();
            } catch (err) {
                errorHandler('Ошибка переподключения: ' + err.message);
            } finally {
                isReconnecting = false;
            }
        }

        function showReconnectButton() {
            reconnectButton.style.display = 'inline-block';
        }

        function hideReconnectButton() {
            reconnectButton.style.display = 'none';
        }

        function getParams() {
            const urlParams = new URLSearchParams(window.location.search);
            const roomId = urlParams.get('room') || 'default-room';
            return { roomId };
        }

        function log(...args) {
            const message = args.join(' ');
            console.log('[DEBUG]', message);
            statusEl.textContent = message;
            statusEl.classList.remove('error');
        }

        function errorHandler(msg) {
            console.error('[ERROR]', msg);
            statusEl.textContent = msg;
            statusEl.classList.add('error');
        }

        window.addEventListener('beforeunload', async () => {
            if (channel) {
                await channel.presence.leave();
            }
            await cleanupPeerConnection();
        });
    </script>
</body>
</html>