<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Auto WebRTC Meeting</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; text-align: center; }
        video { width: 45%; margin: 10px; border: 1px solid #ccc; border-radius: 4px; }
        #status { padding: 10px; margin: 10px; background: #f0f0f0; border-radius: 4px; }
    </style>
    <script src="https://cdn.ably.io/lib/ably.min-1.js"></script>
</head>
<body>
    <h1>Автоматическая видеокомната</h1>
    <div id="status">Подключение...</div>
    <video id="localVideo" autoplay muted playsinline></video>
    <video id="remoteVideo" autoplay playsinline></video>

    <script>
        const ABLY_KEY = 'QBEN4A.NpllMw:gKZi9zUxR4vJRISVloUyOSyO969QngOBQNAvtLSr3ZA';
        const ICE_SERVERS = [
            { urls: 'stun:stun.l.google.com:19302' },
            { urls: 'turn:relay.backups.cz:3478', username: 'webrtc', credential: 'turnserver' }
        ];

        const statusEl = document.getElementById('status');
        const localVideo = document.getElementById('localVideo');
        const remoteVideo = document.getElementById('remoteVideo');

        let localStream;
        let peerConnection;
        let ably;
        let channel;
        let roomId;
        let isCaller = false;

        init();

        async function init() {
            try {
                // Получаем медиаустройства
                localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
                localVideo.srcObject = localStream;

                // Получаем ID комнаты из URL
                roomId = new URLSearchParams(window.location.search).get('room') || 'default-room';
                
                // Подключаемся к Ably
                ably = new Ably.Realtime({
                    key: ABLY_KEY,
                    clientId: 'user-' + Math.random().toString(16).slice(2)
                });

                ably.connection.once('connected', () => {
                    setupPresence();
                });

            } catch (err) {
                errorHandler('Ошибка инициализации: ' + err.message);
            }
        }

        function setupPresence() {
            channel = ably.channels.get(`room-${roomId}`);
            
            // Входим в presence-канал
            channel.presence.enter({ status: 'connected' }, err => {
                if (err) return errorHandler('Ошибка входа в комнату');
                
                // Получаем список участников
                channel.presence.get((err, members) => {
                    if (err) return errorHandler('Ошибка получения участников');
                    
                    // Определяем роль (первый участник - caller)
                    isCaller = members.length === 0;
                    log(isCaller ? 'Вы Caller' : 'Вы Callee');

                    setupConnectionHandlers();
                    
                    // Если есть участники - начинаем подключение
                    if (members.length > 0) {
                        startConnection();
                    }
                });
            });

            // Слушаем новых участников
            channel.presence.subscribe('enter', () => {
                if (isCaller) {
                    startConnection();
                }
            });
        }

        function setupConnectionHandlers() {
            channel.subscribe('signal', msg => {
                if (msg.clientId === ably.auth.clientId) return;

                switch (msg.data.type) {
                    case 'offer':
                        handleOffer(msg.data.offer);
                        break;
                    case 'answer':
                        handleAnswer(msg.data.answer);
                        break;
                    case 'candidate':
                        handleCandidate(msg.data.candidate);
                        break;
                }
            });
        }

        async function startConnection() {
            if (!peerConnection) {
                peerConnection = createPeerConnection();
                localStream.getTracks().forEach(track => {
                    peerConnection.addTrack(track, localStream);
                });

                if (isCaller) {
                    const offer = await peerConnection.createOffer();
                    await peerConnection.setLocalDescription(offer);
                    channel.publish('signal', { type: 'offer', offer });
                }
            }
        }

        async function handleOffer(offer) {
            if (peerConnection || isCaller) return;

            peerConnection = createPeerConnection();
            localStream.getTracks().forEach(track => {
                peerConnection.addTrack(track, localStream);
            });

            await peerConnection.setRemoteDescription(offer);
            const answer = await peerConnection.createAnswer();
            await peerConnection.setLocalDescription(answer);
            channel.publish('signal', { type: 'answer', answer });
        }

        async function handleAnswer(answer) {
            if (!peerConnection) return;
            await peerConnection.setRemoteDescription(answer);
        }

        function handleCandidate(candidate) {
            if (!peerConnection) return;
            peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
        }

        function createPeerConnection() {
            const pc = new RTCPeerConnection({ iceServers: ICE_SERVERS });

            pc.onicecandidate = e => {
                if (e.candidate) {
                    channel.publish('signal', { type: 'candidate', candidate: e.candidate });
                }
            };

            pc.ontrack = e => {
                if (!remoteVideo.srcObject) {
                    remoteVideo.srcObject = new MediaStream();
                }
                e.streams[0].getTracks().forEach(track => {
                    remoteVideo.srcObject.addTrack(track);
                });
            };

            pc.oniceconnectionstatechange = () => {
                statusEl.textContent = `Состояние: ${pc.iceConnectionState}`;
            };

            return pc;
        }

        function log(...args) {
            console.log('[LOG]', ...args);
            statusEl.textContent = args.join(' ');
        }

        function errorHandler(msg) {
            console.error('[ERROR]', msg);
            statusEl.textContent = 'Ошибка: ' + msg;
            statusEl.style.color = 'red';
        }
    </script>
</body>
</html>