<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>WebRTC Automatic Role Assignment</title>
    <style>
        body { font-family: Arial, sans-serif; text-align: center; margin: 20px; }
        video { width: 45%; margin: 10px; border: 1px solid #ccc; border-radius: 4px; }
        #status { padding: 10px; margin: 10px; background: #f0f0f0; border-radius: 4px; display: inline-block; min-width: 300px; text-align: left; }
    </style>
    <script src="https://cdn.ably.io/lib/ably.min-1.js"></script>
</head>
<body>
    <h1>WebRTC Automatic Role Assignment</h1>
    <div id="status">Инициализация...</div>
    <video id="localVideo" autoplay muted playsinline></video>
    <video id="remoteVideo" autoplay playsinline></video>

<script>
const ABLY_KEY = 'QBEN4A.NpllMw:gKZi9zUxR4vJRISVloUyOSyO969QngOBQNAvtLSr3ZA';
const ICE_SERVERS = [{ urls: 'stun:stun.l.google.com:19302' }];

let localStream, peerConnection, ably, channel, pendingCandidates = [];
let isCaller = false;

async function init() {
    try {
        localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
        localVideo.srcObject = localStream;
        
        const roomId = new URLSearchParams(window.location.search).get('room') || 'default-room';
        
        ably = new Ably.Realtime({
            key: ABLY_KEY,
            clientId: 'user-' + Math.random().toString(36).slice(2, 8)
        });

        ably.connection.once('connected', () => {
            setupPresence(roomId);
        });

    } catch (err) {
        errorHandler('Ошибка инициализации: ' + err.message);
    }
}

function setupPresence(roomId) {
    channel = ably.channels.get(`room-${roomId}`);

    channel.presence.get((err, members) => {
        if (err) return errorHandler('Ошибка получения участников: ' + err.message);
        
        if (members.length === 0) {
            channel.presence.enterClient(ably.auth.clientId, { role: 'caller' }, (err) => {
                if (err) return errorHandler('Ошибка входа как caller: ' + err.message);
                isCaller = true;
                log('Вы Caller. Начинаем вызов...');
                startCall();
                setupSignalHandling();
            });
        } else {
            channel.presence.enter({ role: 'callee' }, (err) => {
                if (err) return errorHandler('Ошибка входа как callee: ' + err.message);
                isCaller = false;
                log('Вы Callee. Ожидаем offer...');
                setupSignalHandling();
            });
        }
    });

    channel.presence.subscribe('enter', member => {
        if (member.clientId !== ably.auth.clientId && isCaller) {
            log('Обнаружен новый участник. Повторная отправка offer...');
            startCall();
        }
    });
}

function setupSignalHandling() {
    channel.subscribe('signal', msg => {
        if (msg.clientId === ably.auth.clientId) return;

        switch(msg.data.type) {
            case 'offer': handleOffer(msg.data.offer); break;
            case 'answer': handleAnswer(msg.data.answer); break;
            case 'candidate': handleCandidate(msg.data.candidate); break;
        }
    });
}

async function startCall() {
    if (!isCaller || peerConnection) return;
    
    try {
        peerConnection = createPeerConnection();
        localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));
        
        const offer = await peerConnection.createOffer();
        await peerConnection.setLocalDescription(offer);
        channel.publish('signal', { type: 'offer', offer });
    } catch(err) {
        errorHandler('Ошибка вызова: ' + err.message);
    }
}

async function handleOffer(offer) {
    if (isCaller || peerConnection) return;
    
    try {
        peerConnection = createPeerConnection();
        localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));
        
        await peerConnection.setRemoteDescription(offer);
        const answer = await peerConnection.createAnswer();
        await peerConnection.setLocalDescription(answer);
        channel.publish('signal', { type: 'answer', answer });
        
        processPendingCandidates();
    } catch(err) {
        errorHandler('Ошибка обработки offer: ' + err.message);
    }
}

// Остальные функции (createPeerConnection, handleAnswer, handleCandidate, processPendingCandidates) 
// остаются без изменений из вашего оригинального кода

init();
</script>
</body>
</html>