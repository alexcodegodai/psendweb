<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Auto WebRTC Meeting</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; text-align: center; }
        video { width: 45%; margin: 10px; border: 1px solid #ccc; border-radius: 4px; }
        #status { padding: 10px; margin: 10px; background: #f0f0f0; border-radius: 4px; }
    </style>
    <script src="https://cdn.ably.io/lib/ably.min-1.js"></script>
</head>
<body>
    <h1>Автоматическая видеокомната</h1>
    <div id="status">Подключение...</div>
    <video id="localVideo" autoplay muted playsinline></video>
    <video id="remoteVideo" autoplay playsinline></video>

    <script>
        const ABLY_KEY = 'QBEN4A.NpllMw:gKZi9zUxR4vJRISVloUyOSyO969QngOBQNAvtLSr3ZA';
        const ICE_SERVERS = [
            { urls: 'stun:stun.l.google.com:19302' },
            { urls: 'turn:relay.backups.cz:3478', username: 'webrtc', credential: 'turnserver' }
        ];

        const statusEl = document.getElementById('status');
        const localVideo = document.getElementById('localVideo');
        const remoteVideo = document.getElementById('remoteVideo');

        let localStream;
        let peerConnection;
        let ably;
        let channel;
        let roomId;
        let isCaller = false;
        let clientId;

        async function init() {
            try {
                // Генерация уникального clientId
                clientId = 'user-' + Math.random().toString(36).substr(2, 9);
                
                // Инициализация медиаустройств
                localStream = await navigator.mediaDevices.getUserMedia({ 
                    video: { width: 640, height: 480 },
                    audio: true 
                });
                localVideo.srcObject = localStream;

                // Получение roomId из URL
                roomId = new URLSearchParams(window.location.search).get('room') || 'default-room';
                log(`Инициализация комнаты: ${roomId}`);

                // Подключение к Ably с явным указанием clientId
                ably = new Ably.Realtime({
                    key: ABLY_KEY,
                    clientId: clientId,
                    log: { level: 2 }
                });

                ably.connection.once('connected', () => {
                    log('Успешное подключение к Ably');
                    setupPresenceChannel();
                });

            } catch (err) {
                errorHandler('Ошибка инициализации: ' + err.message);
            }
        }

        async function setupPresenceChannel() {
            channel = ably.channels.get(`room-${roomId}`, { params: { rewind: '1' } });
            
            try {
                // Вход в presence-канал с явным указанием clientId
                await channel.presence.enter({ status: 'connected' });
                log('Успешный вход в presence-канал');

                // Получение списка участников
                const members = await channel.presence.get();
                isCaller = members.length === 0;
                log(`Роль: ${isCaller ? 'Caller' : 'Callee'}`);

                // Настройка обработчиков событий
                channel.presence.subscribe('enter', () => {
                    if (isCaller) startConnection();
                });

                channel.presence.subscribe('leave', handleUserLeave);

                // Подписка на сигналы
                channel.subscribe('signal', handleSignalMessage);

                if (members.length > 0) {
                    startConnection();
                }

            } catch (err) {
                errorHandler('Ошибка работы с presence-каналом: ' + err.message);
            }
        }

        function handleSignalMessage(msg) {
            if (msg.clientId === clientId) return;

            switch (msg.data.type) {
                case 'offer':
                    handleOffer(msg.data.offer);
                    break;
                case 'answer':
                    handleAnswer(msg.data.answer);
                    break;
                case 'candidate':
                    handleIceCandidate(msg.data.candidate);
                    break;
            }
        }

        async function startConnection() {
            try {
                if (peerConnection) return;

                peerConnection = new RTCPeerConnection({ iceServers: ICE_SERVERS });
                setupPeerConnectionHandlers();

                localStream.getTracks().forEach(track => {
                    peerConnection.addTrack(track, localStream);
                });

                if (isCaller) {
                    const offer = await peerConnection.createOffer();
                    await peerConnection.setLocalDescription(offer);
                    channel.publish('signal', { type: 'offer', offer });
                    log('Отправлен offer');
                }
            } catch (err) {
                errorHandler('Ошибка установки соединения: ' + err.message);
            }
        }

        function setupPeerConnectionHandlers() {
            peerConnection.onicecandidate = e => {
                if (e.candidate) {
                    channel.publish('signal', {
                        type: 'candidate',
                        candidate: e.candidate.toJSON()
                    });
                }
            };

            peerConnection.ontrack = e => {
                if (!remoteVideo.srcObject) {
                    remoteVideo.srcObject = new MediaStream();
                }
                e.streams[0].getTracks().forEach(track => {
                    remoteVideo.srcObject.addTrack(track);
                });
                log('Получен удалённый поток');
            };

            peerConnection.oniceconnectionstatechange = () => {
                log(`ICE состояние: ${peerConnection.iceConnectionState}`);
            };
        }

        async function handleOffer(offer) {
            try {
                if (peerConnection || isCaller) return;

                peerConnection = new RTCPeerConnection({ iceServers: ICE_SERVERS });
                setupPeerConnectionHandlers();

                localStream.getTracks().forEach(track => {
                    peerConnection.addTrack(track, localStream);
                });

                await peerConnection.setRemoteDescription(offer);
                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);
                channel.publish('signal', { type: 'answer', answer });
                log('Отправлен answer');

            } catch (err) {
                errorHandler('Ошибка обработки offer: ' + err.message);
            }
        }

        async function handleAnswer(answer) {
            try {
                if (!peerConnection) return;
                await peerConnection.setRemoteDescription(answer);
                log('Установлен answer');
            } catch (err) {
                errorHandler('Ошибка обработки answer: ' + err.message);
            }
        }

        async function handleIceCandidate(candidate) {
            try {
                if (!peerConnection) return;
                await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
            } catch (err) {
                errorHandler('Ошибка обработки ICE кандидата: ' + err.message);
            }
        }

        function handleUserLeave(member) {
            log(`Участник покинул: ${member.clientId}`);
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
                remoteVideo.srcObject = null;
            }
        }

        function log(...args) {
            console.log('[LOG]', ...args);
            statusEl.innerHTML += `<div>${new Date().toLocaleTimeString()}: ${args.join(' ')}</div>`;
        }

        function errorHandler(msg) {
            console.error('[ERROR]', msg);
            statusEl.innerHTML += `<div style="color:red">${new Date().toLocaleTimeString()}: ${msg}</div>`;
        }

        // Запуск приложения
        init();
    </script>
</body>
</html>